/* ABC, my ANSI-compatible Base library for C */
#include <ABC/base.h>

/* X11, windowing library */
#include <X11/X.h>
#include <X11/Xlib.h>

/* OpenGL */
#include <GL/gl.h>
#include <GL/glu.h>
#include <GL/glx.h>

/* The OpenGL attributest required */
GLint att[] = {
  GLX_RGBA,
  GLX_DEPTH_SIZE, 24,
  GLX_DOUBLEBUFFER, None
};

Display                *dpy;    /* The display */
Window                 root;    /* The root window */
XVisualInfo             *vi;    /* The visual info */
Colormap               cmap;    /* Color map */
XSetWindowAttributes    swa;    /* Set window attributes */
Window                  win;    /* The window handle */
GLXContext              glc;    /* The OpenGL context */
XWindowAttributes       gwa;    /* The window attributes */
XEvent                  xev;    /* The window events */
Atom             wm_destroy;    /* The atom to check for window deletion */

int main() {
  /* Get display */
  dpy = XOpenDisplay(NULL);
  ASSERT(dpy != NULL);
  /* Get root window */
  root = DefaultRootWindow(dpy);

  /* Choose visual */
  vi = glXChooseVisual(dpy, 0, att);
  ASSERT(vi != NULL);

  /* Create color map */
  cmap = XCreateColormap(dpy, root, vi->visual, AllocNone);
  /* Fill in some of set window attribs */
  swa.colormap = cmap;
  swa.event_mask = ExposureMask | KeyPressMask;

  /* Create window */
  win = XCreateWindow(
      dpy, root,
      0, 0, 1280, 720,
      0, vi->depth,
      InputOutput,
      vi->visual,
      CWColormap | CWEventMask,
      &swa
  );
  XMapWindow(dpy, win);
  XStoreName(dpy, win, "Xlib OpenGl test");
  /* To cleanly exit X11 */
  wm_destroy = XInternAtom(dpy, "WM_DELETE_WINDOW", 0);
  XSetWMProtocols(dpy, win, &wm_destroy, 1);

  /* Create OpenGL context */
  glc = glXCreateContext(dpy, vi, NULL, GL_TRUE);
  glXMakeCurrent(dpy, win, glc);

  /* Main loop */
  while (1) {
    XNextEvent(dpy, &xev);
    if (xev.type == Expose) {
      ASSERT(xev.xexpose.window == win);
      XGetWindowAttributes(dpy, win, &gwa);
      glViewport(0, 0, gwa.width, gwa.height);
      glClearColor(0.2f, 0.3f, 1.0f, 1.0f);
      glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
      glXSwapBuffers(dpy, win);
    }
    if (xev.type == ClientMessage) {
      ASSERT(xev.xexpose.window == win);
      if (xev.xclient.data.l[0] == (i32)wm_destroy) break;
    }
  }

  /* Destroy window */
  XUnmapWindow(dpy, win);
  XDestroyWindow(dpy, win);
  /* Destroy display */
  XCloseDisplay(dpy);

  return 0;
}
